# 가장 먼 노드
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/49189)
```python
from collections import defaultdict, deque

def bfs(graph, start, distance):
    queue = deque([start])
    distance[start] = 0 # 시작 노드 거리는 0
    # 큐가 빌때까지 반복
    while queue:
        #큐에서 하나의 원소를 뽑기
        v = queue.popleft()
        # 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입
        for i in graph[v]:
            if distance[i] == -1: # 아직 방문 안함
                distance[i] = distance[v] + 1
                queue.append(i)

def solution(n, edge):

    # 1. 그래프 인접 리스트 만들기
    graph = defaultdict(list)
    for a, b in edge:
        graph[a].append(b)
        graph[b].append(a)

    # 2. BFS로 최단 거리 계산
    distance = []
    for _ in range(n+1):
        distance.append(-1)
    bfs(graph, 1, distance)

    # 3. 가장 먼 거리 찾기
    max_dist = max(distance)
    # distance에서 max_dist와 같은 값의 갯수가 정답
    answer = distance.count(max_dist)

    return answer

# print(solution(6, [[3, 6], [4, 3], [3, 2], [1, 3], [1, 2], [2, 4], [5, 2]]))

```

# 순위
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/49191)
```python
def solution(n, results):
    # 1. 그래프 초기화
    graph = []
    # (n+1) * (n+1) 2차원 리스트 False로 초기화
    for _ in range(n+1):
        row = [] # 한 행을 담을 리스트
        for _ in range(n+1):
            # 각 칸은 초기값 False
            row.append(False)
        # 완성된 행을 graph에 추가
        graph.append(row)
    # 인접 행렬 초기화
    for a, b in results:
        graph[a][b] = True # a가 b를 이김

    # 2. 간접 승패 관계 구하기 (플로이드-워셜 알고리즘)
    for m in range(1, n+1):         # 거쳐가는 선수
        for i in range(1, n+1):     # 출발 선수
            for j in range(1, n+1): # 도착 선수
                # graph[i][j] = min(graph[i][j], graph[i][m] + graph[m][j])
                # 플로이드 워셜 알고리즘 응용
                if graph[i][m] and graph[m][j]:
                    graph[i][j] = True
    
    # 3. 정확한 순위 판별 및 카운트
    answer = 0
    for i in range(1, n+1):
        # i가 이긴 사람 수
        win_count  = sum(graph[i][1:])
        # i가 진 사람 수
        lose_count = sum(row[i] for row in graph)
        # 두 수의 합이 n-1이면 순위가 확정됨
        if win_count + lose_count == n-1:
            answer += 1

    return answer


# print(solution(5, [[4, 3], [4, 2], [3, 2], [1, 2], [2, 5]]))

```

# 방의 개수
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/49190)
```python

```