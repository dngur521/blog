# 가장 먼 노드
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/49189)
```python
from collections import defaultdict, deque

def bfs(graph, start, distance):
    queue = deque([start])
    distance[start] = 0 # 시작 노드 거리는 0
    # 큐가 빌때까지 반복
    while queue:
        #큐에서 하나의 원소를 뽑기
        v = queue.popleft()
        # 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입
        for i in graph[v]:
            if distance[i] == -1: # 아직 방문 안함
                distance[i] = distance[v] + 1
                queue.append(i)

def solution(n, edge):

    # 1. 그래프 인접 리스트 만들기
    graph = defaultdict(list)
    for a, b in edge:
        graph[a].append(b)
        graph[b].append(a)

    # 2. BFS로 최단 거리 계산
    distance = []
    for _ in range(n+1):
        distance.append(-1)
    bfs(graph, 1, distance)

    # 3. 가장 먼 거리 찾기
    max_dist = max(distance)
    # distance에서 max_dist와 같은 값의 갯수가 정답
    answer = distance.count(max_dist)

    return answer

# print(solution(6, [[3, 6], [4, 3], [3, 2], [1, 3], [1, 2], [2, 4], [5, 2]]))

```

# 순위
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/49191)
```python

```

# 방의 개수
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/49190)
```python

```