# 같은 숫자는 싫어
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/12906)
```python
def solution(arr):
    answer = []
    stack  = []
    index  = 1
    stack.append(arr[0])

    for index in range(len(arr)):
        stack.append(arr[index])
        if (index == len(arr) - 1):
            answer.append(stack.pop())
            stack = []
            break
        
        elif stack[-1] != arr[index + 1]:
            answer.append(stack.pop())
            stack = []

    return answer
# 스택에 숫자를 집어넣었다가 다른 수가 나오면 스택의 맨 위에 있던 수만 answer 리스트에 append 하고 스택을 초기화 시킨다.(스택에 남아있던 수들 초기화), 이를 반복
# 리스트의 range를 벗어나면 안되기 때문에 index가 arr의 마지막에 다다랐을 때는 따로 처리해주기

```

# 기능개발
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/42586)
```python
import math

def solution(progresses, speeds):
    answer  = [] # 정답 제출용 배열
    end_day = []
    stack   = []
    again   = 1
    length  = len(speeds)
    

    for index in range(length):
        end_day.append(math.ceil((100 - progresses[index]) / speeds[index])) # 올림 함수 적용 (각 progress마다 걸리는 작업 일 수 계산하기)

    for i in range(length):
        stack.append(end_day[i])
        if (i == length - 1): # 배열의 index를 벗어나면 안되기 때문에 i가 end_day 배열의 끝에 다다랐을때 따로 처리해주기
            answer.append(again)
            break

        elif stack[0] < end_day[i + 1]:
            answer.append(again)
            stack = []
            again = 1
        else:
            again += 1

    return answer
```

# 올바른 괄호
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/12909)
```python

```

# 프로세스
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/42587)
```python

```

# 다리를 지나는 트럭
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/42583)
```python

```

# 주식가격 
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/42584)
```python

```