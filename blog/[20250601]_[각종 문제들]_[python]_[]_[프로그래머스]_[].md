# 최솟값 만들기
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/12941)
```python
def solution(A, B):  
    answer = 0
    # 곱의 합을 최소로 만드려면
    # 한 배열에서는 최솟값, 한 배열에서는 최대값을 하나씩 선택해 곱하면 된다
    # 쉽게 말하면 배열 A는 오름차순 정렬, 배열 B는 내림차순 정렬헤서
    # 각 index별로 곱해서 더해버리면 된다

    A.sort()
    B.sort(reverse=True)

    for i, j in zip(A, B):
        answer += i * j


    return answer

# print(solution([1, 4, 2], [5, 4, 4]))

```

# JadenCase 문자열 만들기
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/12951)
```python
def solution(s):
    s = s.lower()
    s_list = list(s)
    
    if str(type(s_list[0])) == "<class 'str'>":
        s_list[0] = s_list[0].upper()

    for i in range(1, len(s_list)):
        if s_list[i] == " " and i + 1 < len(s_list):
            if str(type(s_list[i + 1])) == "<class 'str'>":
                s_list[i + 1] = s_list[i + 1].upper()
        
    answer = ''.join(s_list)
    return answer

# print(solution("3people unFollowed me"))

```

# 이진 변환 반복하기
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/70129)
```python
def solution(s):
    count = 0
    removed_zeros = 0
    
    while s != "1":
        # 0의 갯수 세기
        zeros = s.count("0")
        removed_zeros += zeros
        
        # 0 제거
        s = s.replace("0", "")
        
        # s의 길이 계산 후 이진(binary)으로 변환
        s = bin(len(s))[2:] # 처음 두자리를 자르는 이유: 0bxxxx식으로 나오기 때문
        
        # 변환 횟수 증가
        count += 1
        
    answer = [count, removed_zeros]
    return answer

```

# 숫자의 표현
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/12924)
```python
def solution(n):
    answer = 0
    start = 1
    while start != n+1:
        n_sum = 0
        for i in range(start, n+1):
            n_sum += i
            if n_sum == n:
                answer += 1
                break
            if n_sum > n:
                break
        start += 1
    return answer

# print(solution(15))


```

# 다음 큰 숫자
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/12911)
```python
def solution(n):
    zero = bin(n).count("1")
    answer = n + 1
    while True:
        if bin(answer).count("1") == zero:
            break
        answer += 1

    return answer

# print(solution(15))

```

# 짝지어 제거하기
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/12973)
```python
def solution(s):
    stack = []
    for char in s:
        if stack and stack[-1] == char:
            stack.pop()
        else:
            stack.append(char)
    
    if stack:
        return 0
    
    return 1

# print(solution("baabaa"))
# print(solution("cdcd"))

```

# 피보나치 수
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/12945)
```python
def solution(n):
    a = 0
    b = 1
    for _ in range(2, n + 1):
        a, b = b, (a + b) % 1234567
        # 모듈러 연산의 성질에 의해서 매번 모듈러 연산을 해도 최종 결과와 동일
        # (덧셈에서의 분배 법칙)
    return b
```

# 점프와 순간 이동
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/12980)
```python
def solution(n):
    answer = 0

    while n:
        # n이 짝수면 순간이동만으로 도달 가능
        temp = n % 2
        n = n // 2
        
        if temp == 1:
            answer += 1 # 점프하는 순간(n이 홀수일 경우)

    return answer

# print(solution(5000))
# 더 쉽게 푸는 방법 ==> n을 이진수로 바꿔서 1의 갯수 세기
```

# 귤 고르기
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/138476)
```python
def solution(k, tangerine):
    
    count = {} # 크기별 갯수 담을 리스트

    # 각 크기별 갯수 세서 리스트(count)에 저장
    for x in tangerine:
        if x in count:
            count[x] += 1
        else: 
            count[x] = 1

    # 갯수만 뽑아내서 큰 순서대로(내림차순) 정렬하기
    counts = count.values()
    counts = sorted(counts, reverse=True)

    answer = 0 # 지금까지 체크한 횟수
    total = 0 # 지금까지 담을 수 있는 귤의 총 갯수 (누적 체크한 귤 수)

    for c in counts: # 가장 많이 나온 크기부터 차례대로 보기
        # 누적 체크한 귤 수(total)이 k개가 될때까지 반복문 수행
        # 그때의 체크한 횟수(answer)가 정답임
        total += c
        answer += 1
        if total >= k:
            break

    return answer

# print(solution(6, [1, 3, 2, 5, 4, 5, 2, 3]))

```

# N개의 최소공배수
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/12953)
```python
# 유클리드 호재법으로 최대공약수 구하는 함수
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

# 최소공약수 구하는 함수 (두 수의 곱 / 두 수의 최대공약수)
def lcm(a, b):
    if a == 0 or b == 0:
        return 0
    return abs(a * b) // gcd(a, b)

# 전체 숫자에 대해서 반복하면 최종 최소공약수 구할수 있음
def solution(arr):
    if len(arr) == 1:
        return arr[0]
    
    answer = arr[0]
    for i in range(1, len(arr)):
        answer = lcm(answer, arr[i])

    return answer

# print(solution([2,6,8,14]))
```

# 영어 끝말잇기 
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/12981)
```python
def solution(n, words):
    used_words = []

    for i in range(len(words)):
        person_num = (i % n) + 1 # 사람 번호
        turn = (i // n) + 1 # 차례

        if i > 0:
            # 1. 이전 단어의 마지막 글자와 현재 글자의 첫 글자가 다른 경우 탈락
            if words[i - 1][-1] != words[i][0]:
                return [person_num, turn]
            
        # 2. 현재 단어가 이미 사용 된 경우 탈락
        if words[i] in used_words:
            return [person_num, turn]
        
        used_words.append(words[i]) # 사용한 단어 저장

    # 끝까지 끝말잇기를 성공하였으면 [0, 0] 반환
    return [0, 0]

# print(solution(3, ["tank", "kick", "know", "wheel", "land", "dream", "mother", "robot", "tank"]))
# print(solution(5, ["hello", "observe", "effect", "take", "either", "recognize", "encourage", "ensure", "establish", "hang", "gather", "refer", "reference", "estimate", "executive"]))
# print(solution(2, ["hello", "one", "even", "never", "now", "world", "draw"]))

```

# 예상 대진표 
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/12985)
```python
def solution(n,a,b):
    answer = 1
    temp = 0
    # 항상 b가 더 크게 해서 문제 풀기에 수월하게 함
    if a>b:
        temp = a
        a = b
        b = temp
    
    while (a+1)//2 != (b+1)//2: # 종료조건
        a = (a+1) // 2
        b = (b+1) // 2
        answer += 1

    return answer

# print(solution(8, 4, 7))


```

# 연속 부분 수열 합의 갯수 
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/131701)
```python
def solution(elements):
    # 원형 수열로 확장
    ex_elements = elements * 2

    # set()로 유일한 합 저장(중복 제거)
    answer = set()
    # 모든 연속 부분 수열의 합 계산
    # 길이 length를 1부터 elements의 길이까지 늘려가며 반복
    for length in range(1, len(elements)+1):
        # 시작 위치를 순회하며 부분 수열의 합 계산
        for start in range(len(elements)):
            arr = ex_elements[start : start + length]
            answer.add(sum(arr))
    
    # set에 저장된 원소의 갯수 반환
    return len(answer)

# print(solution([7,9,1,1,4]))

```

# 할인 행사 
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/131127)
```python
def solution(want, number, discount):
    answer = 0
    # 원하는 품목의 딕셔너리 생성
    want_dict = {}
    for obj, count in zip(want, number):
        want_dict[obj] = count

    for i in range(len(discount)-9):
        # 현재 10일간의 할인 품목 리스트 세기
        discount_dict = {}
        for item in discount[i:i+10]:
            discount_dict[item] = discount_dict.get(item, 0) + 1
            if want_dict == discount_dict:
                answer += 1

    return answer

# print(solution( ["banana", "apple", "rice", "pork", "pot"], [3, 2, 2, 2, 1], ["chicken", "apple", "apple", "banana", "rice", "apple", "pork", "banana", "pork", "rice", "pot", "banana", "apple", "banana"]))


```

# 괄호 회전하기
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/76502)
```python
# 문자열에서 올바른 괄호가 있는지 판별하는 함수
def is_true(string):
    # 빈 스택 준비
    stack = []

    # 문자열 순회
    for char in string:
        # 만약 열린 괄호라면 스택에 push
        if char == "(" or char == "[" or char == "{":
            stack.append(char)
        
        # 만약 닫힌 괄호라면
        elif char == ")" or char == "]" or char =="}":
            # 스택이 비어있는 경우 즉시 False 반환
            if len(stack) == 0:
                return False
            # 스택의 top과 짝이 맞으면 해당 열린 괄호 pop
            if char == ")":
                if stack[-1] == "(":
                    stack.pop()
            elif char == "]":
                if stack[-1] == "[":
                    stack.pop()
            elif char == "}":
                if stack[-1] == "{":
                    stack.pop()
            # 스택의 top과 짝이 맞지 않으면
            # 올바르지 않은 순서이므로 False 반환
            else:
                return False
    
    # 순회 완료 후 스택이 비어있는 경우 
    # 모든 괄호가 올바르게 짝을 이루었다는 뜻으로
    # True 반환
    if len(stack) == 0:
        return True
    # 아닌 경우 짝을 찾지 못한 열린 괄호가 있다는 뜻으로
    # False 반환
    else:
        return False

def solution(s):
    answer = 0

    for _ in range(len(s)):
        # 올바른 괄호 판별 
        if (is_true(s)):
            answer += 1
        # s를 왼쪽으로 회전
        s = s[1:] + s[0]

    return answer

# print(solution("[](){}"))

```

# n^2 배열 자르기
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/87390)
```python
# 이 방식은 시간초과 발생함 (O(n^2))
def solution_old(n, left, right):
    # n*n 크기의 2차원 배열 초기화
    arr = [[0] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            # 문제 조건에 맞는 배열 만들기
            if i>j:
                arr[i][j] = i+1
            else:
                arr[i][j] = j+1
    
    # 정답 추출을 위해 1차원 배열로 만들기
    answer = []
    for num in arr:
        answer.extend(num)

    return answer[left:right+1]

# 시간복잡도: O(right - left)인 새로운 풀이 방법
def solution(n, left, right):
    answer = []

    # i는 left ~ right까지의 인덱스
    for i in range(left, right + 1):
        # 1차원 인덱스 i를 2차원 배열의 행(row)과 열(col)로 변환
        row = i // n # i번째 인덱스가 속하는 행의 위치
        col = i % n  # i번째 인덱스가 속하는 열의 위치
        
        # 문제 규칙에 따라 값 계산
        # "1행 1열부터 i행 i열까지의 영역 내의 모든 빈 칸을 숫자 i로 채웁니다."
        # 이때 row와 col은 인덱스 값이니 1을 더해줘야 올바른 값이 나옴
        # 따라서 arr[i][j]의 값은 max(i, j) + 1
        value = max(row, col) + 1
        answer.append(value)
        
    return answer

# print(solution(3, 2, 5))

```

# 행렬의 곱셈
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/12949)
```python
def solution(arr1, arr2):

    # arr1의 행(row)과 arr2의 열(col)을 이용해서 
    # 결과 행렬의 크기 결정
    rows_arr1 = len(arr1)
    cols_arr1 = len(arr1[0])
    cols_arr2 = len(arr2[0])

    # 결과 저장할 행렬 초기화
    answer = [[0] * cols_arr2 for _ in range(rows_arr1)]

    # i: arr1의 행(row) 인덱스
    for i in range(rows_arr1):
        # j: arr2의 열(col) 인덱스
        for j in range(cols_arr2):
            # k: arr1의 열(col)이자 arr2의 행(row) 인덱스
            for k in range(cols_arr1):
                answer[i][j] += arr1[i][k] * arr2[k][j]

    return answer

# print(solution(3, 2, 5))

```

# 캐시
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/17680)
```python
def solution(cacheSize, cities):
    # 캐시 크기가 0이면 모든 요청이 캐시 미스
    # ==> 도시 갯수 * 5 가 총 실행시간
    if cacheSize == 0:
        return len(cities) * 5
    
    answer = 0
    cache = []

    # 대소문자 구분 하지 않으니 전부 소문자로 변경
    cities = [city.lower() for city in cities]

    for city in cities:
        # 캐시 히트
        if city in cache:
            answer += 1
            # 캐시 히트된 도시를 캐시에서 제거 후,
            cache.remove(city)
            # 가장 최근에 사용된 항목이니까 캐시의 맨 뒤에 추가
            cache.append(city)

        # 캐시 미스
        else:
            answer += 5
            # 캐시 미스된 도시를 캐시의 맨 뒤에 추가
            cache.append(city)
            # 캐시 크기를 초과하면 가장 오래된 요소(캐시의 맨 앞)를 제거 
            if len(cache) > cacheSize:
                cache.pop(0)

    return answer

# print(solution(5, ["Jeju", "Pangyo", "Seoul", "NewYork", "LA", "SanFrancisco", "Seoul", "Rome", "Paris", "Jeju", "NewYork", "Rome"]))

```

# 롤케이크 자르기
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/132265)
```python
# 실행 시간 초과된 함수 (list 사용)
def solution_old(topping):
    answer = 0
    # 자를 위치 정하기 
    # 롤케이크를 자를 수 있는 위치는 N-1개
    N = len(topping) - 1
    left_arr  = []
    right_arr = []
    
    # 리스트 슬라이싱과 set() 이용해 왼쪽과 오른쪽 영역의 중복 제거 후 길이 비교
    for i in range(1, N):
        left_arr  = topping[:i]
        right_arr = topping[i:]
        # print(f"left: {set(left_arr)}, right: {set(right_arr)}")
        if len(set(left_arr)) == len(set(right_arr)):
            answer += 1

    return answer

def solution(topping):
    # 초기 상태 설정
    # 모든 토핑이 동생 조각(오른쪽)에 있고,
    # 철수 조각(왼쪽)에는 아무것도 없는 상태
    left_dict  = {}
    right_dict = {}
    for i in range(len(topping)):
        if topping[i] in right_dict:
            right_dict[topping[i]] += 1
        else:
            right_dict[topping[i]] = 1
    
    answer = 0
    # 반복하며 토핑 이동시키기
    # 0 ~ len(topping) - 1까지 순회
    for i in range(len(topping)):
        # 현재 토핑을 오른쪽에서 왼쪽으로 이동
        # 오른쪽에서 갯수 줄이고 값이 0이면 키 삭제
        right_dict[topping[i]] -= 1
        if right_dict[topping[i]] == 0:
            right_dict.pop(topping[i])
        
        # 왼쪽에 토핑 추가
        left_dict[topping[i]] = left_dict.get(topping[i], 0) + 1

        # 공평한 분배 확인
        # 왼쪽과 오른쪽의 토핑 종류 수 계산해서
        # 같으면 answer += 1
        if len(left_dict) == len(right_dict):
            answer += 1

    return answer

# print(solution([1, 2, 1, 3, 1, 4, 1, 2]))

```

# 튜플
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/64065)
```python
def solution(s):
    # 주어진 문자열을 사용하기 쉽게 가공하기
    # 맨 앞과 맨 뒷 글자를 잘라내기 
    # ==> 맨 처음의 "{ 및 "}" 제거 
    s = s[1:-1]
    # 튜플 원소들 사이사이의 반점(,) 제거
    s = s.replace("},{", "} {")
    # 공백을 기준으로 나눈 list 생성
    s_list = s.split(" ")

    nums_list = []
    # 생성된 list는 {}(중괄호)를 기준으로 나누어져 있기 때문에
    # 값을 가공하기 쉽게 [](대괄호)를 기준으로 나누기 (== 2차원 list로 만들기)
    # list의 각 {} 요소마다 반복
    for item in s_list:
        # 대괄호를 없애고, 반점을 기준으로 나눈 값들을 int형으로 변환
        # 만들어진 숫자들을 list에 append (2차원 list 생성)
        nums = item.replace("{", "").replace("}", "")
        nums_str = nums.split(",")
        nums_int = [int(num) for num in nums_str]
        nums_list.append(nums_int)
    # 생성된 2차원 list를 요소들의 길이 순서대로 오름차순 정렬
    nums_sorted = sorted(nums_list, key=len)

    # 정답 제출을 위한 준비
    answer = []         # list
    found_items = set() # 집합

    # 각각 요소들마다 순회
    for items in nums_sorted:
        for item in items:
            # found_items 집합 안에 현재 값이 없으면
            # answer list와 found_item 집합에 값 추가
            # 이때 집합은 중복을 허용하지 않으므로
            # 자연스럽게 중복 체크가 됨
            if item not in found_items:
                answer.append(item)
                found_items.add(item)

    return answer

# print(solution("{{4,2,3},{3},{2,3,4,1},{2,3}}"))

```

# (문제 템플릿)
[문제 링크]()
```python


```

# (문제 템플릿)
[문제 링크]()
```python


```